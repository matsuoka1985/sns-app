name: Deploy Social App (Phase 1 - Minimal)

on:
  watch:
    types: [started]  # Staræ™‚ã®ãƒ‡ãƒ—ãƒ­ã‚¤

  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
        - deploy
        - destroy

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      issues: write
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check Action
        id: check_action
        run: |
          if [ "${{ github.event_name }}" = "watch" ]; then
            echo "action=deploy" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "action=${{ github.event.inputs.action }}" >> $GITHUB_OUTPUT
          else
            echo "action=deploy" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::709588767777:role/sns-app-github-actions-role
          role-session-name: social-app-deploy-session
          aws-region: ap-northeast-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.0"

      - name: Setup Docker Buildx
        if: steps.check_action.outputs.action == 'deploy'
        uses: docker/setup-buildx-action@v3

      - name: Login to Amazon ECR
        if: steps.check_action.outputs.action == 'deploy'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR Repository if not exists
        if: steps.check_action.outputs.action == 'deploy'
        run: |
          aws ecr describe-repositories --repository-names social-app 2>/dev/null || \
          aws ecr create-repository --repository-name social-app --image-scanning-configuration scanOnPush=true

      - name: Build and push Docker image
        if: steps.check_action.outputs.action == 'deploy'
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: social-app
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Laravel PHPã‚¢ãƒ—ãƒªã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ãƒ“ãƒ«ãƒ‰ãƒ»ãƒ—ãƒƒã‚·ãƒ¥
          docker buildx build --platform linux/amd64 \
            --target production \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            -f docker/php/Dockerfile . --push

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Terraform Plan
        if: steps.check_action.outputs.action == 'deploy'
        working-directory: ./terraform
        run: |
          terraform plan \
            -var="ecr_repository_url=${{ steps.login-ecr.outputs.registry }}/social-app:${{ github.sha }}"

      - name: Terraform Apply
        if: steps.check_action.outputs.action == 'deploy'
        working-directory: ./terraform
        run: |
          terraform apply -auto-approve \
            -var="ecr_repository_url=${{ steps.login-ecr.outputs.registry }}/social-app:${{ github.sha }}"

      - name: Terraform Destroy
        if: steps.check_action.outputs.action == 'destroy'
        working-directory: ./terraform
        run: |
          terraform destroy -auto-approve \
            -var="ecr_repository_url=dummy"

      - name: Get Infrastructure Info
        if: steps.check_action.outputs.action == 'deploy'
        working-directory: ./terraform
        id: terraform
        run: |
          CLUSTER_NAME=$(terraform output -raw ecs_cluster_name 2>/dev/null || echo "pending")
          SERVICE_NAME=$(terraform output -raw ecs_service_name 2>/dev/null || echo "pending")
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT

      - name: Wait for ECS Service to be stable
        if: steps.check_action.outputs.action == 'deploy'
        run: |
          echo "â³ Waiting for ECS service to be stable..."
          aws ecs wait services-stable \
            --cluster ${{ steps.terraform.outputs.cluster_name }} \
            --services ${{ steps.terraform.outputs.service_name }} \
            --region ap-northeast-1
          echo "âœ… ECS service is now stable"

      - name: Get Task Public IP
        if: steps.check_action.outputs.action == 'deploy'
        id: get_ip
        run: |
          # Get running task ARN
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ steps.terraform.outputs.cluster_name }} \
            --service-name ${{ steps.terraform.outputs.service_name }} \
            --query 'taskArns[0]' \
            --output text \
            --region ap-northeast-1)
          
          # Get task details and extract public IP
          PUBLIC_IP=$(aws ecs describe-tasks \
            --cluster ${{ steps.terraform.outputs.cluster_name }} \
            --tasks $TASK_ARN \
            --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
            --output text \
            --region ap-northeast-1 | xargs -I {} aws ec2 describe-network-interfaces \
            --network-interface-ids {} \
            --query 'NetworkInterfaces[0].Association.PublicIp' \
            --output text \
            --region ap-northeast-1)
          
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
          echo "ğŸŒ Application will be available at: http://$PUBLIC_IP"

      - name: Create Issue (Deploy Success)
        if: steps.check_action.outputs.action == 'deploy'
        uses: actions/github-script@v7
        with:
          script: |
            const starCount = context.payload.repository?.stargazers_count || 0;
            const title = `ğŸš€ Social App ãƒ‡ãƒ—ãƒ­ã‚¤å®Œäº†! (Phase 1 - Minimal)`;
            const body = `â­ **Phase 1 æœ€å°æ§‹æˆã§ã®ãƒ‡ãƒ—ãƒ­ã‚¤ãŒå®Œäº†ã—ã¾ã—ãŸï¼**
            
            **ğŸ“Š ãƒ‡ãƒ—ãƒ­ã‚¤æƒ…å ±:**
            - æ§‹æˆ: ECS Fargate (Laravel + MySQL + Redis in containers)
            - ã‚¢ã‚¯ã‚»ã‚¹: http://${{ steps.get_ip.outputs.public_ip }}
            - Docker Image: ${{ steps.login-ecr.outputs.registry }}/social-app:${{ github.sha }}
            
            **ğŸ¯ Phase 1ã®ç‰¹å¾´:**
            - âœ… æœ€å°ã‚³ã‚¹ãƒˆæ§‹æˆ
            - âœ… å…¨ã‚µãƒ¼ãƒ“ã‚¹ã‚’ã‚³ãƒ³ãƒ†ãƒŠå†…ã§å®Ÿè¡Œ
            - âœ… ãƒ‘ãƒ–ãƒªãƒƒã‚¯ã‚µãƒ–ãƒãƒƒãƒˆç›´æ¥é…ç½®
            - âœ… HTTPæ¥ç¶šï¼ˆHTTPSåŒ–ã¯å¾Œã®Phaseã§ï¼‰
            
            **ğŸ“ˆ ä»Šå¾Œã®æ‹¡å¼µäºˆå®š:**
            - Phase 2: Route53 + ALB + ãƒ‰ãƒ¡ã‚¤ãƒ³è¨­å®š
            - Phase 3: HTTPSåŒ– (ACMè¨¼æ˜æ›¸)
            - Phase 4: ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚µãƒ–ãƒãƒƒãƒˆ + NAT Gateway
            - Phase 5: RDS + ElastiCacheç§»è¡Œ
            
            **ğŸ›‘ åœæ­¢æ–¹æ³•:**
            Actions â†’ Deploy Social App â†’ Run workflow â†’ destroy
            
            ğŸ¤– Generated with [Claude Code](https://claude.ai/code)`;
            
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['deployment', 'phase-1', 'auto-generated']
            });

      - name: Create Issue (Destroy Completed)
        if: steps.check_action.outputs.action == 'destroy'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `ğŸ§¹ Social App ãƒªã‚½ãƒ¼ã‚¹å‰Šé™¤å®Œäº† (Phase 1)`;
            const body = `**ğŸ›‘ Phase 1 ãƒªã‚½ãƒ¼ã‚¹ã‚’å‰Šé™¤ã—ã¾ã—ãŸ**
            
            **ğŸ“Š å‰Šé™¤ã•ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹:**
            - ECS Cluster/Service/Task Definition
            - VPC/Subnet/Internet Gateway
            - Security Groups
            - CloudWatch Log Groups
            
            **ğŸ’° ã‚³ã‚¹ãƒˆ:**
            - å…¨ã¦ã®ãƒªã‚½ãƒ¼ã‚¹ãŒå‰Šé™¤ã•ã‚Œã€èª²é‡‘ã¯åœæ­¢ã—ã¾ã—ãŸ âœ…
            
            ğŸ¤– Generated with [Claude Code](https://claude.ai/code)`;
            
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['cleanup', 'phase-1', 'auto-generated']
            });

      - name: Emergency Cleanup on Failure
        if: failure() && steps.check_action.outputs.action == 'deploy'
        continue-on-error: true
        working-directory: ./terraform
        run: |
          echo "ğŸš¨ DEPLOYMENT FAILED - Starting cleanup..."
          terraform destroy -auto-approve -var="ecr_repository_url=dummy" || echo "Cleanup completed"